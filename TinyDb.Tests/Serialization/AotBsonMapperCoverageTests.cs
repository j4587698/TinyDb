using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using TinyDb.Serialization;
using TinyDb.Bson;
using TUnit.Core;
using TUnit.Assertions;
using TUnit.Assertions.Extensions;

namespace TinyDb.Tests.Serialization;

public class AotBsonMapperCoverageTests
{
    // A type NOT generated by Source Generator (internal, no attribute)
    internal class NonEntity
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public Dictionary<string, string> Meta { get; set; } = new();
        public List<int> Numbers { get; set; } = new();
    }

    [Test]
    public async Task AotBsonMapper_Fallback_Coverage()
    {
        var entity = new NonEntity { Id = 1, Name = "Test", Meta = { {"k", "v"} }, Numbers = { 1, 2 } };
        
        // This should trigger FallbackToDocument because NonEntity has no SG adapter
        var doc = AotBsonMapper.ToDocument(entity);
        
        await Assert.That(doc).IsNotNull();
        // Fallback uses CamelCase by default in BuildMetadata
        // "Name" -> "name"
        await Assert.That(doc["name"].ToString()).IsEqualTo("Test");
        // Id property resolution -> "_id"
        await Assert.That(doc["_id"].ToInt32(null)).IsEqualTo(1);
        
        // Check dictionary conversion
        var meta = doc["meta"] as BsonDocument;
        await Assert.That(meta).IsNotNull();
        await Assert.That(meta!["k"].ToString()).IsEqualTo("v");
        
        // Check list conversion
        var nums = doc["numbers"] as BsonArray;
        await Assert.That(nums).IsNotNull();
        await Assert.That(nums!.Count).IsEqualTo(2);

        // FallbackFromDocument
        var restored = AotBsonMapper.FromDocument<NonEntity>(doc);
        await Assert.That(restored.Id).IsEqualTo(1);
        await Assert.That(restored.Name).IsEqualTo("Test");
        await Assert.That(restored.Meta["k"]).IsEqualTo("v");
        await Assert.That(restored.Numbers.Count).IsEqualTo(2);
    }

    [Test]
    public async Task ConvertPrimitiveValue_Coverage()
    {
        // Test ConvertValue edge cases
        
        // BsonString -> various
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("true"), typeof(bool))).IsEqualTo(true);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("123"), typeof(int))).IsEqualTo(123);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("123"), typeof(long))).IsEqualTo(123L);
        
        // Enum
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("Monday"), typeof(DayOfWeek))).IsEqualTo(DayOfWeek.Monday);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonInt32(1), typeof(DayOfWeek))).IsEqualTo(DayOfWeek.Monday);
        
        // Guid from BsonBinary
        var guid = Guid.NewGuid();
        var bytes = guid.ToByteArray();
        var bin = new BsonBinary(bytes, BsonBinary.BinarySubType.Uuid);
        await Assert.That(AotBsonMapper.ConvertValue(bin, typeof(Guid))).IsEqualTo(guid);
        
        // ObjectId from String
        var oid = ObjectId.NewObjectId();
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString(oid.ToString()), typeof(ObjectId))).IsEqualTo(oid);
        
        // Arrays
        var byteArr = new byte[] { 1, 2, 3 };
        var binArr = new BsonBinary(byteArr);
        await Assert.That(AotBsonMapper.ConvertValue(binArr, typeof(byte[]))).IsTypeOf<byte[]>();
        
        // More numeric types
        await Assert.That(AotBsonMapper.ConvertValue(new BsonInt32(100), typeof(short))).IsEqualTo((short)100);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonInt32(100), typeof(byte))).IsEqualTo((byte)100);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonInt32(100), typeof(long))).IsEqualTo(100L);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonInt32(100), typeof(float))).IsEqualTo(100f);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonInt32(100), typeof(double))).IsEqualTo(100.0);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonInt32(100), typeof(decimal))).IsEqualTo(100m);
        
        // From string to numbers
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("100"), typeof(short))).IsEqualTo((short)100);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("100"), typeof(int))).IsEqualTo(100);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("100"), typeof(long))).IsEqualTo(100L);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("100.5"), typeof(float))).IsEqualTo(100.5f);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("100.5"), typeof(double))).IsEqualTo(100.5);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonString("100.5"), typeof(decimal))).IsEqualTo(100.5m);
        
        // From double
        await Assert.That(AotBsonMapper.ConvertValue(new BsonDouble(100.0), typeof(int))).IsEqualTo(100);
        await Assert.That(AotBsonMapper.ConvertValue(new BsonDouble(100.0), typeof(long))).IsEqualTo(100L);
    }

    [Test]
    public void ConvertValue_ShouldThrow_ForUnsupportedTypes()
    {
        // Boolean -> DateTime (Not supported in switch)
        try { AotBsonMapper.ConvertValue(new BsonBoolean(true), typeof(DateTime)); Assert.Fail("Should throw"); } catch (NotSupportedException) {}
        catch (FormatException) {} // Fallback might try Parse
        
        // Array -> int (Not supported)
        try { AotBsonMapper.ConvertValue(new BsonArray(), typeof(int)); Assert.Fail("Should throw"); } catch (NotSupportedException) {}
        catch (InvalidCastException) {}
        catch (FormatException) {}
    }
}
